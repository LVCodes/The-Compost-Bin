Lauren Vogel   COP4530   Fall 2020

This project focuses on generating Huffman codes to compress a given string. A Huffman code uses a set of prefix code to compress the string with no loss of data (lossless). David Huffman developed this algorithm in the paper “A Method for the Construction of Minimum-Redundancy Codes” (http://compression.ru/download/articles/huff/huffman_1952_minimum-redundancy-codes.pdf)

A program can generate Huffman codes from a string using the following steps:
• Generate a list of the frequency in which characters appear in the string using a map
• Inserting the characters and their frequencies into a priority queue (sorted first by the lowest frequency and then lexicographically)
• Until there is one element left in the priority queue
• Remove two characters/frequencies pairs from the priority queue
• Turn them into leaf nodes on a binary tree
• Create an intermediate node to be their parent using the sum of the frequencies for those children
• Put that intermediate node back in the priority queue
• The last pair in the priority queue is the root node of the tree
• Using this new tree, encode the characters in the string using a map with their prefix code by traversing the tree to find where the character’s leaf is. When traversal goes left, add a 0 to the code, when it goes right, add a 1 to the code
• With this encoding, replace the characters in the string with their new variable-length prefix codes

In addition to the compress string, it will need to be able to serialize the tree. Without the serialized version of the Huffman tree, it will not be able to decompress the Huffman codes. Tree serialization will organize the characters associated with the nodes using post order. During the post order when it visits a node,
• if it, the node, is a leaf (external node) then add a L plus the character to the serialize tree string
• if it is a branch (internal node) then add a B to the serialize tree string

For decompression, two input arguments will be needed. The Huffman Code that was generated by the compress method and the serialized tree string from the serializeTree method. The Huffman tree will have to be built by deserializing the tree string by using the leaves and branches indicators. After getting the tree back, it can decompress the Huffman Code by tracing the tree to figure out what variable length codes represent actual characters from the original string.
So, for example, if we are compressing the string “if a machine is expected to be infallible it cannot also be intelligent”:
Our compress algorithm would generate the following codes for the characters:

Character  Frequency  Prefix Code
(space)    12         00
a          5          1011
b          3          10101
c          3          11000
d          1          010000
e          9          100
f          2          01011
g          1          010001
h          1          010010
i          8          011
l          6          1101
m          1          010011
n          6          1110
o          3          11001
p          1          010100
s          2          10100
t          6          1111
x          1          010101

Our code would be:
0110101100101100010011101111000010010011111010000011101000010001010101010010011000111110001000000111111001001010110000011111001011101111011101011101011101100000111111001100010111110111011001111100101111011010011001001010110000011111011111001101110101101000110011101111

And our serialize tree would look like:
L LdLgBLhLmBBLpLxBLfBBLiBBLeLsLbBLaBBLcLoBLlBLnLtBBBB

One class for this project needs to be created: HuffmanTree for the compression, decompression, and serialization that uses a linked binary tree. A Heap-based Priority Queue is given for the sorting. The STL map, vector, and stack, are allowed to be used but not the STL priority queue.

Other things in Huffman hpp/cpp
To simplify the process, the full interface and implementation for a class called HuffmanNode is provided. This class has all the basics for a tree node (leaf, branch, root, data members for linking, accessor) and also includes a comparator class for use with the heap. This code should not need to be altered for this node.

Deliverables
Please submit complete project including:
• HuffmanTree.cpp (Your written HuffmanTree class)
• HuffmanTree.hpp (Your written HuffmanTree class)
• HeapQueue.hpp (The given Heap Priority Queue using an array/vector class)
• HuffmanBase.cpp (The provided base class and helper class)
• HuffmanBase.hpp (The provided base class and helper class)
• PP4Test.cpp (Test file)
• TestStrings.hpp (Test file)
• catch.hpp (Catch2 Header)
And any additional source and header files needed for the project.
